# あなたはこれから友人と N 回じゃんけんをします。しかし、あなたは全てを見通す千里眼の持ち主なので、友人がこれから出す N 回のじゃんけんの手が全て分かってしまいました。
# ただただ全勝してしまうのは面白くないので、あなたは、N 回のじゃんけんで出した指の本数の合計がちょうど M 本になるようにじゃんけんをすることにしました。
# このとき、あなたは最高で何回じゃんけんに勝つことができるでしょうか。
# ここで、上の文中に出てくる「出した指の本数」というのは、じゃんけんで出した手の何本の指が立っていたか、ということであり、グー、チョキ、パーそれぞれ

# ・グー　のとき ... 0 本
# ・チョキのとき ... 2 本
# ・パー　のとき ... 5 本

# の指を出していたということになります。
# 例えば、あなたが 4 回のじゃんけんで グー、パー、チョキ、グー と出したとすると、出した指の本数の合計は、

# 0 + 5 + 2 + 0 = 7

# で 7 本となります。


# 入力される値
# 入力は以下のフォーマットで与えられます。

# N M
# s

# 1 行目にそれぞれじゃんけんを行う回数を表す整数 N、あなたが出す指の本数の合計を表す整数 M がこの順で半角スペース区切りで与えられます。
# 続いて 2 行目に長さ N の文字列 s が与えられます。s の i 番目 (1 ≦ i ≦ N) の文字は i 回目のじゃんけんで相手が出す手を表し、それぞれグーが "G"、チョキが "C"、パーが "P" で表されます。
# 入力は合計で 2 行となり、2 行目の末尾に改行が 1 つ入ります。


# 入力値最終行の末尾に改行が１つ入ります。
# 文字列は標準入力から渡されます。


# 期待する出力
# あなたの勝つ回数の最大値を整数で出力してください。


# 条件
# すべてのテストケースにおいて、以下の条件をみたします。

# ・1 ≦ N ≦ 1,000
# ・0 ≦ M ≦ 5,000
# ・s_i (1 ≦ i ≦ N) は半角英大文字で "G", "C", "P" のいずれかである。
# ・N 回のじゃんけんでちょうど M 本の指を出すじゃんけんの仕方が少なくとも 1 通り存在する。


# 入力例1
# 4 7
# CGPC

# 出力例1
# 4

# 入力例2
# 5 10
# GPCPC

# 出力例2
# 3

# -------------------------------------------------

# 方針
# じゃんけんの順番は適当に並べ替えてもよいこと
# 出せる指の本数の合計が決まっているため、パーを出す回数を決めるとチョキの回数がおのずと決まることに気が付くと、自分がパー (またはチョキ) を出す回数について全探索することで、答えを求めることが出来ます。
# なお、出す指の本数がちょうど M 本となっていなければならないことに注意してください。
# グー、チョキ、パーを自分が g, c, p 回、相手が enemy_g, enemy_c, enemy_p 回出すとき、自分がじゃんけんに勝てる回数は最大で min (g, enemy_c) + min (c, enemy_p) + min (p, enemy_g) 回です。
# min (g, enemy_c) ←が意味するのは、例えばじゃんけんをした回数などは考慮せず、「自分がグーを 3 回、相手がチョキを 1 回出す」という条件のみで考えた場合、自分がじゃんけんで勝てる最大の回数は 1 回ということです。
# 「自分がグーを 4 回、相手がチョキを 6 回出す」という条件の場合、自分がじゃんけんで勝てる最大の回数は 4 回となります。
# つまり、 (g, enemy_c) の内、小さい方の数が最大勝利回数となります。

# maxメソッドの定義
def max(a, b)
  # 条件演算子 (?:) の文法は、`式1 ? 式2 : 式3` で、`if 式1 then 式2 else 式3 end` と同義になります。（三項演算子とも呼ぶ）
  # 条件式 ? 真の時の値 : 偽の時の値
  # 以下の場合、 a > b が、 true のとき a を返し false のとき b を返します。
  a > b ? a : b
end

# minメソッドの定義
def min(a, b)
  a < b ? a : b
end

n, m = gets.split.map(&:to_i)
s = gets.chomp

s_g = s.count('G')  # 相手が出す "G" の回数
s_c = s.count('C')  # 相手が出す "C" の回数
s_p = s.count('P')  # 相手が出す "P" の回数

win_max = 0  # 最大勝利回数を定義

# 以下のループ処理ではまず、自分が出せる指の本数 m を基に、その値と一致するパーとチョキの組み合わせを洗い出し、その上でジャンケンの回数 n を考慮した条件分岐を行います。 
# (自分が出せる指の本数 m / 5) をすることで n 回の勝負におけるパーが出せる最大の数が分かります。
# 例えば、 m = 18 の場合、18回の勝負におけるパーが出せる回数は、 18 / 5 == 3 なので 3 回となります。
# downto(min) は self から min まで 1 ずつ減らしながらブロックを繰り返し実行します。
(m / 5).downto(0) do |pa|
  # (自分が出せる指の本数 - 5 × パーを出した回数) / 2 をすることで n 回の勝負におけるチョキが出せる最大の数が分かります。
  ch = (m - 5 * pa) / 2
  # じゃんけんを行う回数から、パーを出した回数とチョキを出した回数を引き、グーを出した回数を求めます。
  gu = n - pa - ch

  # negative? は self が 0 未満の場合に true を返します。
  # もし gu (グーを出す回数) が 0 未満の場合、 break によりループ処理を抜けます。(回数が 0 未満になることはなく、もし計算式でそうなってしまうのであれば、それはパーもしくはチョキの出し過ぎということが言え、この問題の条件を満たさないことになるため)
  # gu が 0 未満になる場合、パーとチョキを出した合計回数が n（じゃんけんの回数） を上回ってしまっていることになります。
  # なぜ処理を抜けるのかというと、このループ処理では、繰り返し処理が行われる毎に gu の値は小さくなるようになっています。ある処理のタイミングで gu がマイナスの値になった場合、それ以降の繰り返し処理を実行しても gu の値が 0 以上になることはないためです。
  break if gu.negative?
  # next により、自分が出せる指の本数 (m本) が、実際に自分が出す指の本数 (5 * pa + 2 * ch) と一致しない場合の処理をスキップします。
  # なぜスキップするのかというと、このじゃんけんゲームにおいて、指定された指の本数 (m本) になるようにグー、チョキ、パーを組み合わせて出さなければならないという最低限のルールがあるからです。
  # ちなみに、繰り返しが入れ子になっている場合は next が実行された一番内側の繰り返しに関して次の繰り返しへ進みます。
  next if m != 5 * pa + 2 * ch

  # min の引数として、「相手が出すチョキの回数と自分が出すグーの回数」、「相手が出すパーの回数と自分が出すチョキの回数」、「相手が出すグーの回数と自分が出すチョキの回数」を渡し、グーを出した時、チョキを出した時、パーを出した時のそれぞれの最大勝利数を求めます。
  # max の引数として、「現状の win_max の値」と、「グー、チョキ、パーそれぞれの最大勝利数を足したもの」を渡し、それらを比較し値が大きい方をwin_maxに代入します。
  win_max = max(win_max, min(s_c, gu) + min(s_p, ch) + min(s_g, pa))
end

puts win_max

# パーを出す回数を全探索しています。

# -------------------------------------------------

# スキルチェック見本問題
# じゃんけんの手の出し方 
# https://paiza.jp/works/mondai/skillcheck_sample/janken?language_ruby

# 入力
input_1 = gets.split(" ")
n = input_1[0].to_i   # じゃんけんを行う回数、1 <= n <= 1000
m = input_1[1].to_i   # あなたが出す指の本数の合計、0 <= m <= 5000
puts "じゃんけんを行う回数:#{n}、指の合計:#{m}"


s = gets    # じゃんけんで相手が出す手, 半角英大文字で "G", "C", "P", 長さn
puts "相手が出す手:" + s


# 相手の手に対して全て勝つとしたら、それぞれの手の最大数
pmax = s.count("G")     # G:グーに対して勝つ、パーの回数
cmax = s.count("P")     # P:パーに対して勝つ、チョキの回数
gmax = s.count("C")     # C:チョキに対して勝つ、グーの回数

puts "パーの最大回数:#{pmax}、チョキの最大回数:#{cmax}、グーの最大回数:#{gmax}"


# n回の勝負について、各手を出す回数を全探索する
# すべての手の順列を求めなくてもいい
# 最終的に求めるのは最大の勝利回数なので、*組み合わせ*を求める
# たとえば、4回の勝負のうち、
# グーの回数:2、チョキの回数:1、パーの回数:1と分かれば
# 指の本数と、最大勝利数は求められる

win_max = 0     # 最大の勝利回数、初期値はゼロ

for pp in 0..n
    for cc in 0..(n - pp)
        gg = n - pp - cc
        puts "パーの回数:#{pp}、チョキの回数:#{cc}、グーの回数:#{gg}"
        
        fingers = pp * 5 + cc * 2    # 指の数の合計を求める
        if fingers == m then
            puts "match!"
            # この回の手で勝つ数を求める
            # そのために、この回の特定の手の回数と、最大勝利回数の小さいほうを足し合わせる
            # たとえば：
            # この回ではパーを3回出して、そのうち最大2回勝つなら > パーの勝利数は2回
            # この回ではパーを1回出すけど、最大2回勝つなら > パーの勝利数は1回
            win = [pp, pmax].min + [cc, cmax].min + [gg, gmax].min
            
            # 最大の勝利数なら入れ替える
            win_max = [win, win_max].max
        end
    end
end

puts win_max